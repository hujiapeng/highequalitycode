1. 包名全小写、类名首字母大写、常量全部大写并用下划线分割、变量采用驼峰命名法
2. 三元操作符类型问题：<br/>
 <code>int i=80;<br/>
 String str=String.valueOf(i<100?90:100.0)</code><br/>
 str值为字符串90.0<br/>
 解释：90为整型，100.0为浮点型，三元操作符需要转换为相同的操作类型，所以int类型转float类型变为90.0，str为90.0
3. 显示声明序列化serialVersionUID：如果不显示声明，将要被序列化的对象会在被编译的时候自动生成版本号。JVM在发序列化时，会比较数据流中serialVersionUID与类的serialVersionUID是否相同，如果相同，则认为类没有发生改变，可以把数据流load为实例对象；如果不相同则抛出InvalidClassException异常
4. 反序列化中，不使用构造函数为final变量赋值：反序列化时构造函数不会执行
5. 序列化文件存的是类文件描述信息，包括路径、继承关系、访问权限、变量描述、变量访问权限、方法签名、返回值以及变量的关联关系，不记录方法、构造函数、static变量等的具体实现（注意static变量反序列化对应值是JVM中的缓存值，可以通过在反序列化之前修改static变量值，然后打印反序列化结果查看）
6. 实现Serializable接口的类，可以通过添加序列化委托方法writeObject和反序列化委托方法readObject来控制序列化和反序列化，这种方式是序列化独有的机制，序列化回调。Java调用ObjectOutputStream类把一个对象转换成数据流时，会通过反射检查被序列化的类是否有writeObject方法，并检查其是否符合私有、无返回值的特性，若有则会调用委托方法进行对象序列化，若没有则由ObjectOutputStream按照默认规则继续序列化；同样反序列化时，也会检查私有无返回值的readObject方法，如果有就执行该方法，没有就默认序列化。比如对序列化类某字段特殊处理，可以通过在属性前加transient来避免序列化或反序列化该属性，然后可以通过添加writeObject和readObject委托方法来特殊处理
7. switch语句中千万不要忘记break。如果没有break，switch语句会从第一个case符合后，下面所有case和default的代码都执行
8. 